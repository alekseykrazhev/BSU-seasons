и осуществляет перемещение с адреса зю этих двух букв. при этом инфа хранится в перевернутом виде, поэтому поссле обработки транслятором этой хуйни с адреса зю будет располагаться код д и код "я". если было бы зю дб яд, то было бы наоборот. далее, записана строчка
zuzu dw 255 dup(?)
эта строчка означает, что после двух байтов д и я будет отвкдено 255 раз по слову (по 2 байта). т.е., начиная с адреса zuzu 255 раз будет зарезервиравано место в ОЗУ.
//ебейший рассказ сказки
далее строчка
.code - это директива транслятору, которая говорит что далее будет ассемьлер - команды машинного языка записанные в виде команд яза ассемблер
транслятор все что после этой строчки осуществит перевод крманды на машинном языке.
далее описана точка входа - zu:
mov ax,@data
mov ds,ax
нельзя сразу, тк есть ограничение на возможности использования сегментных регистров. сегментный адрес можно только в ax, и после переместить в регистр ds.
по комнде первойв регистр ax помещается адрес сегмента данных. т.е. это число, определяющее местоположение семента данных. по второй команде это число идет в ds.
далее строчки
mov ah,10
lea dx,Zu
int 21h
т.е. говорится о том, что по этой команде регистр ah помещается число 10. для прерывания 21h и для всех сущ. прерываний функция-обработчик прерывания (ее номер) должна быть в регистре ah.
10 функция делает следующее - осуществляет ввод последовательности символов с клавиатуры, а точнее ввод кодов символов с клавы. не номеров, а именно кодов символов в соответствии с использовуемой кодировкой. причем для 10й функции область памяти должен быть опписан спец образом, при этом адрес области ввода должен быть в dx, а сама область - описана так, и никак иначе в первом байте этой области памяти. число с фиксированной точкой, которая для 10й функции определяет макс колво символов, которое может быть введено с клавы. второй байт должен быть зарезервирован для числа, которое должно быть возвращено 10й ф-ей и должно быть равно колву введенных символов. и далее желательно чтобы в сегменте данных было достаточно места для вводимых символов, тк начиная с 3го байта области ввода будут располагаться коды вводимых символов. в связи со сказанным, эти три команды приведут к слудующему: прерывание 21h обратитьс к фии 10 этого прерывания.
функция 10 полезет в регистр dx, куда будет делаться ввод. и эта 10я ф-я обратившись в область памяти zu залезет в первый байт, где находится русской буквы Д и в зависимости от кодировки этот код будет определять макс колво символов, которое может быть введено.
в частности, в вопросе 6,0 говорится о том, что необзодимо рассмотреть варианты двух кодировок - основная и альтернативная. они отличаются тем, каким образом в доп части таблицы располагаются русские буквы. в одной из них русские буквы начинаются с кода 80. в другой начинаются с кода A0. соответственно в зависимости от кодировки ответ на вопрос будет таким - в случае когда в кодиров таблице исп кодировка, где рус буквы с А0 код буквы Д = 84 в шестн. равно хызы. в другом случае можно ввести 132 символа. далее будет писк компа. во второй байт будет помещено 84(вроде). в том случае, если исп кодировка с А0 код будет А4=164.
нужно четко представлять какая кодировка используется и в блокноте и в досбоксе.
